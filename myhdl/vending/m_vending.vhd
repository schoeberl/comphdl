-- File: m_vending.vhd
-- Generated by MyHDL 0.9dev
-- Date: Fri Feb  7 10:28:50 2014


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_09.all;

entity m_vending is
    port (
        clock: in std_logic;
        reset: in std_logic;
        button: in unsigned(3 downto 0);
        led: out unsigned(7 downto 0)
    );
end entity m_vending;
-- 

architecture MyHDL of m_vending is


constant C_DISP_CODE: integer := 195;
constant DebounceMs: integer := 4;
constant C_ERROR_CODE: integer := 2**8-1;
constant TicksPerMs: integer := 50000;
constant MaxTick: integer := 200000000;


type t_enum_States_1 is (
    WAIT,
    RELEASE,
    COINAGE,
    DISPENSE,
    ERROR,
    END
);

signal bitem: unsigned(3 downto 0);
signal ccoin: unsigned(4 downto 0);
signal ticks: unsigned(28 downto 0);
signal ccost: unsigned(6 downto 0);
signal state: t_enum_States_1;
signal itemi: unsigned(2 downto 0);
signal _button: unsigned(3 downto 0);
signal user_reset: std_logic;
signal bbounce: unsigned(3 downto 0);

begin




M_VENDING_RTL_BITS2INT: process (bbounce) is
begin
    if ((bbounce > 0) and (bbounce < 9)) then
        case to_integer(bbounce) is
            when 0 => bitem <= "1111";
            when 1 => bitem <= "0001";
            when 2 => bitem <= "0010";
            when 3 => bitem <= "1111";
            when 4 => bitem <= "0011";
            when 5 => bitem <= "1111";
            when 6 => bitem <= "1111";
            when 7 => bitem <= "1111";
            when 8 => bitem <= "0100";
            when 9 => bitem <= "1111";
            when 10 => bitem <= "1111";
            when 11 => bitem <= "1111";
            when 12 => bitem <= "1111";
            when 13 => bitem <= "1111";
            when 14 => bitem <= "1111";
            when others => bitem <= "1111";
        end case;
    else
        bitem <= to_unsigned(0, 4);
    end if;
end process M_VENDING_RTL_BITS2INT;


M_VENDING_RTL_COIN: process (bitem, itemi, state) is
begin
    case to_integer(bitem) is
        when 0 => ccoin <= "00000";
        when 1 => ccoin <= "00001";
        when 2 => ccoin <= "00101";
        when 3 => ccoin <= "01010";
        when others => ccoin <= "11001";
    end case;
    if (state = COINAGE) then
        case to_integer(itemi) is
            when 0 => ccost <= "0000000";
            when 1 => ccost <= "0010100";
            when 2 => ccost <= "1100100";
            when 3 => ccost <= "0101000";
            when others => ccost <= "0110111";
        end case;
    end if;
end process M_VENDING_RTL_COIN;


M_VENDING_RTL_SM: process (clock) is
    variable itemb: unsigned(3 downto 0);
    variable total: unsigned(6 downto 0);
begin
    if rising_edge(clock) then
        if (reset = '1') then
            state <= WAIT;
            ticks <= to_unsigned(0, 29);
            led <= to_unsigned(0, 8);
            itemi <= to_unsigned(0, 3);
            itemb := to_unsigned(0, 4);
            total := to_unsigned(0, 7);
        else
            ticks <= (ticks + 1);
            if bool(user_reset) then
                state <= END;
            elsif (state = WAIT) then
                total := to_unsigned(0, 7);
                if ((bbounce > 0) and (bbounce < 9)) then
                    itemb := button;
                    itemi <= resize(bitem, 3);
                    ticks <= to_unsigned(0, 29);
                    state <= RELEASE;
                    led <= shift_left(resize(itemb, 8), 2);
                end if;
            elsif (state = RELEASE) then
                if (bbounce = 0) then
                    state <= COINAGE;
                end if;
            elsif (state = COINAGE) then
                if ((ticks >= MaxTick) or (total > ccost)) then
                    state <= ERROR;
                    led <= to_unsigned(C_ERROR_CODE, 8);
                elsif ((bbounce > 0) and (bbounce < 9)) then
                    total := (total + ccoin);
                    if (total = ccost) then
                        state <= DISPENSE;
                        ticks <= to_unsigned(0, 29);
                        itemi <= to_unsigned(1, 3);
                        led <= to_unsigned(C_DISP_CODE, 8);
                    else
                        state <= RELEASE;
                        ticks <= to_unsigned(0, 29);
                    end if;
                end if;
            elsif (state = DISPENSE) then
                if (signed(resize(ticks, 30)) > (500 * TicksPerMs)) then
                    ticks <= to_unsigned(0, 29);
                    itemi <= (itemi + 1);
                    if ((itemi mod 2) = 1) then
                        led <= shift_left(resize(itemb, 8), 2);
                    else
                        led <= to_unsigned(C_DISP_CODE, 8);
                    end if;
                    if (itemi = 6) then
                        state <= END;
                    end if;
                end if;
            elsif (state = END) then
                state <= WAIT;
                led <= to_unsigned(0, 8);
            elsif (state = ERROR) then
                led <= to_unsigned(C_ERROR_CODE, 8);
            else
                assert False
                    report "*** AssertionError ***"
                    severity error;
            end if;
        end if;
    end if;
end process M_VENDING_RTL_SM;


M_VENDING_RTL_DEBOUNCE: process (clock) is
begin
    if rising_edge(clock) then
        if (reset = '1') then
            _button <= to_unsigned(0, 4);
            bbounce <= to_unsigned(0, 4);
        else
            if ((signed(resize(ticks, 30)) mod (TicksPerMs * DebounceMs)) = 0) then
                _button <= button;
                if (button = _button) then
                    bbounce <= button;
                end if;
            end if;
        end if;
    end if;
end process M_VENDING_RTL_DEBOUNCE;


M_VENDING_RTL_USER_RESET: process (bbounce) is
    variable bcnt: integer;
begin
    bcnt := 0;
    for ii in 0 to 4-1 loop
        if bool(bbounce(ii)) then
            bcnt := (bcnt + 1);
        end if;
    end loop;
    if (bcnt > 1) then
        user_reset <= '1';
    else
        user_reset <= '0';
    end if;
end process M_VENDING_RTL_USER_RESET;

end architecture MyHDL;
